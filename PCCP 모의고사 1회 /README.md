[PCCP 모의고사 1회 사이트](https://school.programmers.co.kr/learn/courses/15008/15008-pccp-%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC-1%ED%9A%8C)

# 문제 설명
<details>
  <summary> 1. 외톨이 알파벳 </summary>

> 알파벳 소문자로만 이루어진 어떤 문자열에서, 2회 이상 나타난 알파벳이 2개 이상의 부분으로 나뉘어 있으면 `외톨이 알파벳`이라고 정의합니다.
> <br/><br/>
> 문자열 `edeaaabbccd`를 예시로 들어보면,
> - a는 2회 이상 나타나지만, 하나의 덩어리로 뭉쳐있으므로 `외톨이 알파벳`이 아닙니다.
>   - `ede(aaa)bbccd`
> - b, c도 a와 같은 이유로 `외톨이 알파벳`이 아닙니다.
> - d는 2회 나타나면서, 2개의 부분으로 나뉘어 있으므로 `외톨이 알파벳`입니다.
>   - `e(d)eaaabbcc(d)`
> - e도 d와 같은 이유로 `외톨이 알파벳`입니다.<br/><br/>
>
> 문자열 `eeddee`를 예시로 들어보면,
> - e는 4회 나타나면서, 2개의 부분으로 나뉘어 있으므로 `외톨이 알파벳`입니다.
>   - `(ee)dd(ee)`
> - d는 2회 나타나지만, 하나의 덩어리로 뭉쳐있으므로 `외톨이 알파벳`이 아닙니다.
>   - `ee(dd)ee`<br/><br/>
>
> 문자열 `input_string`이 주어졌을 때, `외톨이 알파벳`들을 알파벳순으로 이어 붙인 문자열을 return 하도록 solution 함수를 완성해주세요. 만약, `외톨이 알파벳`이 없다면 문자열 `N`을 return 합니다.<br/><br/>
> 
> ## 제한사항
> - 1 ≤ `input_string`의 길이 ≤ 2,600
> - `input_string`은 알파벳 소문자로만 구성되어 있습니다.<br/><br/>
> ## 입출력 예
> |input_string|result|
> |:---:|:---:|
> |`edeaaabbccd`|`de`|
> |`eeddee`|`e`|
> |`string`|`N`|
> |`zbzbz`|`bz`|
> ## 입출력 예 설명
> ##### 입출력 예 #1
> - 문제 예시와 같습니다.
> - `외톨이 알파벳`인 e, d를 알파벳순으로 이어 붙여 문자열을 만들면 `de`가 됩니다.
> ##### 입출력 예 #2
> - 문제 예시와 같습니다.
> ##### 입출력 예 #3
> - 모든 문자들이 한 번씩만 등장하므로 `외톨이 알파벳`이 없습니다.
> ##### 입출력 예 #4
> - `외톨이 알파벳`인 z, b를 알파벳순으로 이어 붙여 문자열을 만들면 `bz`가 됩니다.<br/><br/>
</details>

풀이 시간 : `17:32` [`문제 풀이`](#1-외톨이-알파벳-풀이)

<details>
  <summary> 2. 체육대회 </summary>

> 당신이 다니는 학교는 매년 체육대회를 합니다. 체육대회는 여러 종목에 대해 각 반의 해당 종목 대표가 1명씩 나와 대결을 하며, 한 학생은 최대 한개의 종목 대표만 할 수 있습니다. 당신의 반에서도 한 종목당 1명의 대표를 뽑으려고 합니다. 학생들마다 각 종목에 대한 능력이 다르지만 이 능력은 수치화되어 있어 미리 알 수 있습니다. 당신의 반의 전략은 각 종목 대표의 해당 종목에 대한 능력치의 합을 최대화하는 것입니다.
> 다음은 당신의 반 학생이 5명이고, 종목의 개수가 3개이며, 각 종목에 대한 학생들의 능력치가 아래 표와 같을 때, 각 종목의 대표를 뽑는 예시입니다.
> ||테니스|탁구|수영|
> |---:|:---:|:---:|:---:|
> |석환|40|10|10|
> |영재|20|5|0|
> |인용|30|30|30|
> |정현|70|0|70|
> |준모|100|100|100|
> 
> 테니스 대표로 준모, 탁구 대표로 인용, 수영 대표로 정현을 뽑는다면, 세 명의 각 종목에 대한 능력치의 합은 200(=100+30+70)이 됩니다.
> 하지만, 테니스 대표로 석환, 탁구 대표로 준모, 수영 대표로 정현을 뽑는다면 세 명의 각 종목에 대한 능력치 합은 210(=40+100+70)이 됩니다. 이 경우가 당신의 반의 각 종목 대표의 능력치 합이 최대가 되는 경우입니다.<br/><br/>
> 당신의 반 학생들의 각 종목에 대한 능력치를 나타내는 2차원 정수 배열 `ability`가 주어졌을 때, 선발된 대표들의 해당 종목에 대한 능력치 합의 최대값을 return 하는 solution 함수를 완성하시오.<br/><br/>
> 
> ## 제한사항
> - 1 ≤ `ability`의 행의 길이 = 학생 수 ≤ 10
> - 1 ≤ `ability`의 열의 길이 = 종목 수 ≤ `ability`의 행의 길이
> - 0 ≤ `ability[i][j]` ≤ 10,000
> - `ability[i][j]`는 `i+1`번 학생의 `j+1`번 종목에 대한 능력치를 의미합니다.<br/><br/>
> ## 입출력 예
> |ability|result|
> |---|:---:|
> |[[40, 10, 10], [20, 5, 0], [30, 30, 30], [70, 0, 70], [100, 100, 100]]|210|
> |[[20, 30], [30, 20], [20, 30]]|60|
> ## 입출력 예 설명
> ##### 입출력 예 #1
> - 문제 예시와 같습니다.
> ##### 입출력 예 #2
> - 1번 학생이 2번 종목을, 2번 학생이 1번 종목의 대표로 참가하는 경우에 대표들의 해당 종목에 대한 능력치의 합이 최대가 되며, 이는 60입니다.<br/><br/>
</details>

풀이 시간 : `33:19` [`문제 풀이`](#2-체육대회-풀이)

<details>
  <summary> 3. 유전법칙 </summary>

> 멘델은 완두콩을 이용하여 7년간 실험한 결과, 다음과 같은 특별한 법칙을 발견하였습니다.
> + 둥근 완두 순종(RR)을 자가 수분, 즉 같은 유전자끼리 교배할 경우, 다음 세대에 둥근 완두 순종 형질만 나타난다.
> + 주름진 완두 순종(rr)을 자가 수분할 경우, 다음 세대에 주름진 완두 순종 형질만 나타난다.
> + 두 순종을 교배한 잡종(Rr)을 자가 수분할 경우, 다음 세대의 형질은 RR:Rr:rr=1:2:1의 비율로 나타난다. (아래 그림 참조)<br/><br/>
> 
> <img width="500" src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/22c1e8fc-093c-491b-8604-dad8f553b631/image1.PNG"><br/><br/>
> 멘델의 법칙을 공부한 진송이는, 직접 완두콩의 자가 수분 실험을 진행했습니다. 진송이의 실험에서 완두콩 한 개를 자가 수분한 결과는 다음과 같습니다.
> 
> + 각 완두콩은 자가 수분해서 정확히 4개의 완두콩 후손을 남긴다.
> + 잡종 완두콩(Rr)은 자가 수분해서 첫째는 RR, 둘째와 셋째는 Rr, 넷째는 rr 형질의 후손을 남긴다.
> + 순종 완두콩(RR, rr)은 자가 수분해서 자신과 같은 형질의 후손을 남긴다.
> 잡종 완두콩(Rr) 1대부터 시작한 가계도로 그려보면 그림 2와 같습니다.<br/><br/>
>
> <img width="600" src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/95a0f907-0e3c-4c4e-acfe-bb489685802b/image2.PNG"><br/><br/>
> 진송이는 이러한 완두콩의 자가 수분 실험 결과를 정리하고 싶어합니다. 하지만, 세대를 거듭할수록, 완두콩의 수가 너무 많아져 모든 가계도를 기록하기 어려워졌습니다. 진송이는 가계도를 전부 기록하는 것 대신, 완두콩의 세대와 해당 세대에서 몇 번째 개체인지를 알면 형질을 바로 계산하는 프로그램을 만들려 합니다.<br/><br/>
> 각 세대에서 맨 왼쪽 개체부터 첫 번째, 두 번째, 세 번째, ...개체로 나타냅니다. 예를 들어 그림 2에서 2세대의 네 번째 개체의 형질은 "rr"이며, 3세대의 9번째 개체의 형질은 "RR"입니다.<br/><br/>
> 형질을 알고 싶은 완두콩의 세대를 나타내는 정수 `n`과, 해당 완두콩이 세대 내에서 몇 번째 개체인지를 나타내는 정수 `p`가 2차원 정수 배열 `queries`의 원소로 주어집니다. `queries`에 담긴 순서대로 `n`세대의 `p` 번째 개체의 형질을 문자열 배열에 담아서 return 하도록 solution 함수를 완성해주세요.<br/><br/>
> ## 제한사항
> - 1 ≤ queries의 길이(쿼리의 개수) ≤ 5
> - queries의 원소는 [n, p] 형태입니다.
>   - 1 ≤ n ≤ 16
>   - 1 ≤ p ≤ 4n-1<br/><br/>
> ## 입출력 예
> |queries|result|
> |:---|:---|
> |[[3, 5]]|["RR"]|
> |[[3, 8], [2, 2]]|["rr", "Rr"]|
> |[[3, 1], [2, 3], [3, 9]]|["RR", "Rr", "RR"]|
> |[[4, 26]]|["Rr"]|
> ## 입출력 예 설명
> ##### 입출력 예 #1
> - 본문의 가계도를 참고하면 3세대의 5번째 개체의 형질이 RR임을 알 수 있습니다.
> ##### 입출력 예 #2
> - 본문의 가계도를 참고하면 3세대의 8번째 개체의 형질이 rr임을 알 수 있습니다.
> - 본문의 가계도를 참고하면 2세대의 2번째 개체의 형질이 Rr임을 알 수 있습니다.
> ##### 입출력 예 #3
> - 본문의 가계도를 참고하면 3세대의 1번째 개체의 형질이 RR임을 알 수 있습니다.
> - 본문의 가계도를 참고하면 2세대의 3번째 개체의 형질이 Rr임을 알 수 있습니다.
> - 본문의 가계도를 참고하면 3세대의 9번째 개체의 형질이 RR임을 알 수 있습니다.
> ##### 입출력 예 #4
> - 4세대의 26번째 개체는 3세대의 7번째 개체(Rr)의 둘째 후손으로, 형질은 Rr이 됩니다.<br/><br/>
</details>

풀이 시간 : `` [`문제 풀이`](#3-유전법칙-풀이)

<details>
  <summary> 4. 운영체제 </summary>

> 개발자 준모는 운영체제를 만들었습니다. 준모가 만든 운영체제는 프로그램의 우선순위와 호출된 시각에 따라 실행 순서를 결정합니다. 모든 프로그램에는 1부터 10까지의 점수가 매겨져 있으며, 이 점수가 낮을수록 우선순위가 높은 프로그램입니다. 각 프로그램들은 실행 시간이 정해져 있으며 프로그램이 호출되면 대기상태에 있다가 자신의 순서가 되면 실행 시간 동안 실행된 뒤 종료됩니다.<br/><br/>
> 준모가 만든 운영체제는 호출된 프로그램들 중 우선순위가 가장 높은 프로그램을 먼저 실행합니다. 호출된 각 프로그램은 자신보다 우선순위가 높은 호출된 프로그램이 모두 종료된 후에 실행됩니다. 단, 실행 중인 프로그램보다 우선순위가 높은 프로그램이 호출되어도 실행 중이던 프로그램은 중단되지 않고 종료될 때까지 계속 실행됩니다. 또한, 우선순위가 같은 프로그램들 중에서는 먼저 호출된 프로그램이 먼저 실행됩니다.<br/><br/>
> 다음은 1번부터 4번까지의 4개의 프로그램이 호출된 예시입니다.<br/><br/>
> <img width="600" src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/2545585a-8c01-4085-8e82-a2bec7803453/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C1.png"><br/><br/>
> 예를 들어, 1번부터 4번까지 4개의 프로그램의 점수가 순서대로 2, 1, 3, 3이며, 호출된 시각은 0, 5, 5, 12초이고, 수행시간은 10, 5, 3, 2라고 가정해 봅시다.
> + 1번 프로그램이 0초에 호출될 때 실행 중인 프로그램이 없으므로, 0초에 1번 프로그램이 바로 실행됩니다. 1번 프로그램은 10초에 종료되며, 2, 3번 프로그램이 새로 호출됐습니다.
> + 호출된 2, 3번 프로그램 중 2번 프로그램의 점수가 1로 우선순위가 높습니다. 2번 프로그램은 5초에 호출되어 10초에 실행될 때까지 5초 동안 대기했습니다. 2번 프로그램은 15초에 종료되며, 4번 프로그램이 새로 호출됐습니다.
> + 호출된 3, 4번 프로그램은 점수가 같지만, 3번 프로그램이 먼저 호출되었기 때문에 3번 프로그램이 먼저 실행됩니다. 3번 프로그램은 5초에 호출되어 15초에 실행될 때까지 10초 동안 대기했습니다. 3번 프로그램은 18초에 종료됩니다.
> + 4번 프로그램이 마지막으로 실행되며, 4번 프로그램은 12초에 호출되어 18초에 실행될 때까지 6초 동안 대기했습니다. 4번 프로그램은 20초에 종료됩니다.
>   
> 모든 프로그램이 종료되는 시각은 20초이며, 각 프로그램이 대기한 시간은 순서대로 0, 5, 10, 6초입니다. 점수가 1인 프로그램의 대기시간 합은 5고, 점수가 3인 프로그램의 대기시간 합은 16 임을 알 수 있습니다.<br/><br/>
> 프로그램들의 정보를 나타내는 2차원 정수 배열 `program`이 주어질 때, 모든 프로그램들이 종료되는 시각과 프로그램의 점수마다 대기시간의 합을 정수 배열에 담아 return 하는 solution 함수를 완성하세요. return 해야 하는 `answer` 배열은 길이가 11인 정수 배열입니다. `answer[0]`은 모든 프로그램들이 종료되는 시각을 의미하며, `answer[i]`(1 ≤ i ≤ 10)는 프로그램의 점수가 i인 프로그램들의 대기시간의 합을 의미합니다.<br/><br/>
> ## 제한사항
> - 1 ≤ `program`의 길이 ≤ 100,000
> - `program[i]`은 i+1번 프로그램의 정보를 의미하며, [a, b, c]의 형태로 주어집니다.
>   - a는 프로그램의 점수를 의미하며, 1 ≤ a ≤ 10 을 만족합니다.
>   - b는 프로그램이 호출된 시각을 의미하며, 0 ≤ b ≤ 10,000,000을 만족합니다.
>   - c는 프로그램의 실행 시간을 의미하며, 1 ≤ c ≤ 1,000을 만족합니다.
>   - a, b쌍이 중복되는 프로그램은 입력으로 주어지지 않습니다. 즉, 호출된 시각이 같으면서 점수도 같은 프로그램은 없습니다.
> ## 입출력 예
> |program|result(answer)|
> |:---|:---|
> |[[2, 0, 10], [1, 5, 5], [3, 5, 3], [3, 12, 2]]|[20, 5, 0, 16, 0, 0, 0, 0, 0, 0, 0]|
> |[[3, 6, 4], [4, 2, 5], [1, 0, 5], [5, 0, 5]]|[19, 0, 0, 4, 3, 14, 0, 0, 0, 0, 0]|
> ## 입출력 예 설명
> ##### 입출력 예 #1
> - 문제 예시와 같습니다.
> ##### 입출력 예 #2
> - 그림으로 나타내면 아래 그림과 같습니다.<br/><br/>
>   <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/68bb44c8-beba-453f-932a-301dbca10e8b/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C2.png"><br/><br/>
</details>

풀이 시간 : `` [`문제 풀이`](#4-운영체제-풀이)

---

# 풀이

  - ### 1. 외톨이 알파벳 풀이
    알파벳 리스트를 만들어 정규식을 이용하여 간단하게 확인할 수 있다.
    - #### 생각할 점
      `input_string`을 기준으로 외톨이 글자가 있는 지 없는 지 확인하려 할 수 있는데, `input_string`은 최대 2600자까지 들어오므로 알파벳을 기준으로 했을 때보다 오히려 훨씬 많은 시간이 걸릴 수 있다.<br/><br/>
      `input_string`을 수정할 경우 외톨이 알파벳을 잘못 가져올 수 있으므로 하지 않는 것이 좋다.
    - #### TIPS
      <details>
        <summary>아스키 코드로 배열 만들기</summary>

        > - javascript
        >   ```
        >   Array.from({ length: 26 }, (v, i) => String.fromCharCode(i + 65)) //대문자 알파벳 리스트 생성(1)
        >   Array(26).fill().map((v, i) => String.fromCharCode(i + 65)) //대문자 알파벳 리스트 생성(2)
        >   
        >   Array.from({ length: 26 }, (v, i) => String.fromCharCode(i + 97)) //소문자 알파벳 리스트 생성(1)
        >   Array(26).fill().map((v, i) => String.fromCharCode(i + 97)) //소문자 알파벳 리스트 생성(2)
        >   ```
        > - python3
        >   ```
        >   list(string.ascii_uppercase) # string에 내재된 함수를 이용하여 대문자 알파벳 리스트 생성
        >   list(map(chr, range(65, 91))) # 대문자 알파벳 리스트 생성
        >   
        >   list(string.ascii_lowercase) # string에 내재된 함수를 이용하여 소문자 알파벳 리스트 생성
        >   list(map(chr, range(97, 123))) # 소문자 알파벳 리스트 생성
        >   ```
      </details>
      <details>
        <summary>문자열 포매팅</summary>

        > - javascript
        >   ```
        >   //기본 포매팅
        >   "{0}, {1}".format(val0, val1)
        >   
        >   //format 함수 이용
        >   String.format("{0} + {1} = {2}", val0, val1, val2)
        >   
        >   //정규 표현식 이용
        >   "%자료형종류 + %자료형종류 = %자료형종류", val0, val1, val2
        >   
        >   //ES6 템플릿 문자열과 백틱을 이용한 문자열 포매팅
        >   `${val0} + ${val1} + ${val2} = ${val3}`
        >   ```
        > - python3
        >   ```
        >   # %포매팅
        >   "%자료형종류 %자료형종류" %(val0, val1)
        >   
        >   # format 함수 이용
        >   "{0}{1}".format(val0,val1) #0번째에 N의 자리 정수로 값을 고정시키고 싶을 경우 {0:0Nd}
        >   
        >   #f-string 문법
        >   f'{매개변수}로 치환 가능'
        >   ```
        > - 공통 참고 사항
        >
        > |%자료형종류|설명|비고|
        > |:---:|:---:|:---:|
        > |%s|문자열|-|
        > |%d|정수|%0Nd 의 경우 N자리의 정수|
        > |%f|실수|%0.Nf 의 경우 소수점 N자리의 실수|
        > |%o|8진수|-|
        > |%x|16진수|-|
      </details>
      <details>
        <summary>정규 표현식</summary>

        > - javascript
        >   ```
        >   //정규 표현식을 나타내는 3가지 방법
        >   
        >   /정규표현식/flag
        >   new RegExp("정규표현식", "flag")
        >   new RegExp(/정규표현식/, "flag")
        >   ```
        > - python3
        >   ```
        >   import re
        >   
        >   re.compile('정규표현식', flag)
        >   ```
        > - 공통 참고 사항
        >
        > |메타문자|설명|
        > |:---:|:---|
        > |^x|문자열이 x로 시작|
        > |x$|문자열의 끝이 x로 종료|
        > |.x|x로 종료|
        > |x+|x가 한 번 이상 문자열에 존재|
        > |x?|x가 존재할 수도, 않을 수도 있음|
        > |x*|x가 0번 이상 문자열에 존재|
        > |x\|y|문자열에 x혹은 y존재|
        > |(x)|x를 그룹으로 처리|
        > |(x)(y)|순서에 맞게 x, y를 각 그룹의 데이터로 관리|
        > |(x)(?:y)|그룹들의 집합에 대한 예외 표현|
        > |x{n}|x가 n번 반복됨|
        > |x{n,}|x가 n번 이상 반복됨|
        > |x{n,m}|x가 n번 이상 m번 이하 반복됨|
        > |[xy]|x와 y 중 하나|
        > |[^xy]|x와 y 제외|
        > |[x-z]|x~z 사이의 문자|
        > |\^|^를 문자로 사용함|
        > |\b|문자와 공백 사이의 문자|
        > |\B|문자와 공백 사이가 아닌 문자|
        > |\d|정수|
        > |\D|숫자가 아닌 문자|
        > |\s|공백 문자|
        > |\S|공백이 아닌 문자|
        > |\t|탭 문자 의미|
        > |\v|수직 탭 의미|
        > |\w|알파벳, 숫자, 공백 중 한 문자|
        > |\W|알파벳, 숫자, 공백이 아닌 문자|<br/><br/>
        >
        > |FLAG|의미|
        > |:---:|:---|
        > |g|대상 문자열 내에서 모든 패턴을 검색|
        > |i|대상 문자열에 대해 대/소문자를 식별하지 않음|
        > |m|대상 문자열이 다중 라인의 문자열인 경우에도 검색|
      </details>
      <details>
        <summary>함수 표현식</summary>

        > - javascript
        >   ```
        >   // 기존 함수
        >   function (input) => {
        >   return ''
        >   }
        >
        >   // 화살표 함수
        >   (input) => '';
        >   ```
        > - python3
        >   ```
        >   # 기존 함수
        >   def function_name(input) :
        >     return '';
        >
        >   # lambda 함수
        >   lambda input : 표현식, 범위
        >   #ex ) map(lambda x: x ** 2, range(5))
        >   ```
      </details>
  - ### 2. 체육대회 풀이
    SAMPLE MESSAGE<br/><br/>
    
  - ### 3. 유전법칙 풀이
    SAMPLE MESSAGE<br/><br/>
    
  - ### 4. 운영체제 풀이
    SAMPLE MESSAGE<br/><br/>
    
